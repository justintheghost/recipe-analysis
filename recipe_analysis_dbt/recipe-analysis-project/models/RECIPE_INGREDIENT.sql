{{ config(materialized='table') }}

WITH RECIPE_JSON AS (
    SELECT PARSE_JSON(RECIPE_DATA_JSON) AS JSON_DATA FROM RAW_RECIPE_JSON
), RECIPE_BY_INGRED AS (
SELECT json_data:recipe_name::string AS RECIPE_NAME
  , value:ingredient:ingredient_name::string AS INGREDIENT_NAME
  , value:ingredient:ingredient_sequence::numeric AS INGREDIENT_SEQUENCE
  , value:ingredient:ingredient_type::string AS INGREDIENT_TYPE
  , * 
FROM RECIPE_JSON, lateral flatten(input => JSON_DATA:recipe_ingredients)
), RECIPE_BY_INGRED_HEADER AS (
SELECT RECIPE_NAME
    , INGREDIENT_NAME 
    , INGREDIENT_SEQUENCE
    , INGREDIENT_TYPE
    , CASE WHEN INGREDIENT_TYPE = 'Section Header' THEN INGREDIENT_NAME ELSE null END AS HEADER_NAME
FROM RECIPE_BY_INGRED
), RECIPE_ASSIGN_HEADERS AS (  
SELECT T.RECIPE_NAME
    , T.INGREDIENT_NAME
    , T.INGREDIENT_TYPE
    , CONCAT(T.RECIPE_NAME,T.INGREDIENT_NAME,T.INGREDIENT_SEQUENCE) AS INGREDIENT_UNIQUE_ID
    , FIRST_VALUE(T.HEADER_NAME) OVER (PARTITION BY T.RECIPE_SECTION_SEQUENCE ORDER BY T.INGREDIENT_SEQUENCE) AS RECIPE_SECTION 
FROM (
    SELECT RECIPE_NAME
        , INGREDIENT_NAME
        , INGREDIENT_SEQUENCE       
        , INGREDIENT_TYPE
        , HEADER_NAME        
        , SUM(CASE WHEN HEADER_NAME IS NULL THEN 0 ELSE 1 END) OVER (ORDER BY INGREDIENT_SEQUENCE) AS RECIPE_SECTION_SEQUENCE
    FROM RECIPE_BY_INGRED_HEADER
    ) AS T
)

SELECT 
{{ dbt_utils.surrogate_key('INGREDIENT_UNIQUE_ID') }} AS RECIPE_INGREDIENT_ID
    , RECIPE_NAME
    , INGREDIENT_NAME
    , RECIPE_SECTION
    , GETDATE() AS ETL_LAST_UPDATED  
FROM RECIPE_ASSIGN_HEADERS
WHERE INGREDIENT_TYPE = 'Ingredient'
